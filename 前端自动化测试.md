# 前端自动化

**原理:通过编写test.js方法并运行,使得需要执行的函数会对比预期结果和实际结果进行对比,如果不一致则抛出错误和相关信息**

```
function test(desc, fn) {
    try {
        fn()
        console.log(`${desc}通过测试`);
    } catch (e) {
        console.log(`${desc}没有通过测试`);
    }
}

function expect(result) {
    return {
        toBe: function(actual) {
            if (result !== actual) {
                throw new Error(`预期值和实际值不相同 预期${actual} 结果却是${result}`)
            }
        }
    }
}

test('测试内容', () => {
    expect('测试方法').toBe()
})
```



## 前端自动化测试框架:JEST
+ 特点:性能、功能和易用性都比较好
1. 速度快
2. API简单
3. 易配置
4. 隔离性好
5. 监控模式
6. IDE整合
7. Snapshot（快照）
8. 多项目并行
9. 覆盖率
10. Mock丰富

### 安装
```
npm install --save-dev jest
```

### 特点
1. JEST主要进行单元测试和集成测试两类内容
2. 单元测试可以认为是一个模块的测试，集成测试看做是多个模块的测试，所以代码方法需要导出成为模块才能测试
3. 如果在导出代码之后无法在浏览器内运行，可以通过加入try-catch包裹导出包裹的代码
4. 可以通过package.json文件中设置jest来实现npm run test的运行
```
"scripts": {
        "test": "jest"
},
```
5. 如过jest不进行配置,jest会执行默认配置


### jest配置
1. 通过npx jest --init进行初始化
2. 然后选择node环境或者浏览器环境
3. 选择jest使用覆盖率报告   npx jest --coverage可以看到报告,目录也会生成新的文件
4. 选择清除模拟调用
5. 然后会生成jest.config.js文件
6. 相关代码可配置项
```
module.exports = {
	clearMocks: true, 		//是否自动清除模拟的事情
	coverageDirectory: "coverage",	//生成代码覆盖率报告放置的文件夹项
	browser: false			//浏览器环境
}
```
7. jest在node环境下无法识别ESmodule的语法,只能识别commendJs的语法,所以需要通过babel进行配置
```
<!-- 安装bebel相关插件 -->
cnpm install @babel/core @babel/preset-env -D
<!-- 在.babelrc设置 -->
{
    "presets": [
        ["@babel/preset-env",{
            "targets":{
                "node":"current"
            }
        }]
    ]
}
```
8. babel配置后的运行方式:在执行npm run jest之后jest会执行jest里面的babel-jest文件,然后通过babel-core安装.babelrc配置文件对待吗进行转化,之后再运行转化过的测试代码
9. 监听所有测试 加上watchAll
```
"scripts": {
    "test": "jest --watchAll"
  }
```

### 匹配器
匹配器|内容
--|:--
toBe()|匹配内容和引用地址都相同则通过
toEqual()|匹配对象内容相同则通过
toBeNull()|匹配对象是否为null,不用传参数
toBeUndefined()|匹配对象是否为undefined,不用传参数
toBeTruthy()|匹配是否为真,不用传参数
toBeFalsy()|匹配是否为假,不用传参数
not.匹配器方法()|取反
toBeGreaterThan()|比某个数大
toBeLessThan()|比某个数大
toBeGreaterThanOrEqual()|比某个数大或等于
toBeLessThanOrEqual()|比某个数小或等于
toBeCloseTo()|解决js中浮点数的计算,替代相等值equal
toMatch()|匹配字符串是否相等
toContain()|匹配数组中是否包含某个值
toThrow()|匹配函数能否抛出异常

### 异步代码测试
1. 测试用例
```
test('fetchData返回结果',()=>{
	return fetchData().then((response)=>{
		expect(response.data).toEqual({
			success:true
		})
	})
	})
```
2. 测试是否为404
```
test('fetchData返回结果',()=>{
	expect.assertions(1)		//至少执行一次expect结果
	return fetchData().catch((e)=>{
		expect(e.toString().indexOf('404')>-1).toBe(true)
	})
})
```
3. 测试是否异常
```
<!-- 语法1 -->
test('fetchData返回结果404',()=>{
	return expect(fetchData()).reject.toThrow()
	})
})
<!-- 语法2 -->
test('fetchData返回结果',async ()=>{
	await expect(fetchData()).resolves.toMatchObject({
		data:{
			success:true
		}
	})
   })
})
<!-- 语法3 -->
test('fetchData返回结果',async ()=>{
	const response=await fetchData()
	expect(response.data).toEqual({success:true})
	})
})
<!-- 语法4-->
test('fetchData返回结果',async ()=>{
	try{
		await fetchData()
	}caych(e){
		expect(e.toSting()).toEqual('字符串')
	}
  })
})
```


### JEST中的钩子函数
1. 测试代码
```
beforeAll(()=>{
	<!-- 在所有测试之前 -->
})
test('测试方法',()=>{
	ClassName.functionOne()		//执行类的方法
	expect(属性变量).toBe()
})

```
2. 钩子函数
钩子函数|作用
--|:--
beforeAll()|在所有测试用例测试之前执行的钩子函数
afterAll()|在所有测试用例测试之后执行的钩子函数
beforeEach()|在每一个测试用例之前都执行的钩子函数
afterEach()|在每一个测试用例之后都执行的钩子函数
3. 可以使用describe('测试代码分模块',()=>{})对相关代码进行层次结构分解
4. 钩子函数的函数作用域:对describe内部作用都有效,执行流程:先执行外部
5. 钩子函数的执行流程:(由外到内)先执行外部的钩子函数,再执行内部的钩子函数
6. 可以通过test.only()跳过其他测试方法,只对该测试方法进行测试
### JEST的Mock函数
**mock的用法:**
+ 捕获函数的调用和返回的结果,以及this和调用顺序
+ 可以让我们能自由设置返回结果
+ 改变函数的内部实现

1. 使用jest.fn()来捕获函数的调用,看函数是否被调用
```
test('测试callback',()=>{
	const func=jest.fn();	
	<!-- 自由设置返回的值 -->
	func.mockReturnValueOnce("返回的值")		//函数执行第一次会返回一个"返回的值"
	func.mockReturnValue("返回的值")			//函数执行的每一次都会返回"返回的值"
	runCallback(func);		//自定义的回调函数
	expect(func).toBeCalled()				//测试mock函数是否有回调
	expect(func.mock.calls.length).toBe(1)	//测试回调mock函数执行的次数
	expect(func.mock.calls[0]).toEqual(['abc'])//测试mock的回调函数返回的某个结果
})
```
2. 前端测试ajax请求一般只测试请求是否发送了请求,不去测试返回真实的数据,通过mockResolvedValue改变函数的内部实现
```
test('测试axios',async ()=>{
	axios.get.mockResolvedValue({data:'数据1'})		//模拟axios请求,并mock假数据
	await getData().then((data)=>{			//测试的异步获取方法
		expect(data).toBe('数据1');
	})
})
```
3. 新建一个__mocks__文件夹用做mock数据,然后再test文件里使用jest.mock('./mock数据文件名字')实现jest在__mocks__文件夹寻找数据文件名字进行请求的测试
4. 编写一个文件,用文件里的数据替换掉项目真实的代码
```
test('fetchData测试', ()=>{
	return fetchData().then(data=>{
		expect(eval(data)).toEqual('123')
	})
})
<!-- _mock文件夹__ -->
export const fetchData = ()=>{
	return new Promise((resolved,reject)=>{
		resolved("(function(){return '123})()")
	})
}
```
5. 可以使用jest.unmock('./')来实现拒绝mock操作来拒绝测试

### JEST snapshot测试
1. 使用expect().Snapshot()第一次执行会生成一个快照文件,后面再执行会与第一次生成的快照文件作对比。如果一直相等则会一直通过。
2. 快照可以用于配置/设置文件的测试，用于检测配置/设置文件是否发生改变或者异样。
```
test('测试axios',async ()=>{
	expect(config()).toMatchSnapshot()
})
```
3. 假如配置项有类似Date()一直变化可以在toMatchSnapshot()中加入对象进行配置
```
expect(config()).toMatchSnapshot({
	time:expect.any(Date)
})
```

### JEST timer定时器设置
1. 对定时器timer进行测试
```
<!-- 测试代码 -->
export default (callback) =>{
	setTimeout(()=>{
		callback()
	},3000)
}
<!-- 模拟代码 -->
import timer from './timer'
jest.useFakeTimers()		//凡是涉及定时器的代码用该语句替代
test('timer测试',()=>{
	const fn=jest.fn()	//mock函数
	timer(fn)		//这个是外部导入需要测试的函数,正常执行的异步操作需要等待定时器的时长
	*jest.runAllTimers()		//直接执行(看做定时器时间为0),不等待定时器,和jest.useFakeTimers()配对使用
	*jest.advanceTimerByTime(3000)	//时间快进3秒
	expect(fn).toHaveBeenCalledTimes(1)		//检测定时器预期运行次数
})
```

### 通过对类的Mock理解单元测试和集成测试
1. 简单的类的测试只要创建实例,然后测试实例方法结果即可.
2. jest.mock('./util'):jest.mock会发现util是一个类,会自动把类的构造函数和方法变成jset.fn()
```
<!-- 原理实现的代码 -->
const Util=jest.fn()
Util.prototype.a=jest.fn()
Util.prototype.b=jest.fn()
<!-- 因为Util是一个mock的数据所以相应提高性能 -->
```
3. 测试用例可以使用toHaveBeenCalled()测试是否被执行过
```
test('测试demoFunction',()=>{
	demoFunction()						//执行类里面的方法写在demoFunction()里运行
	expect(Util).toHaveBeenCalled()		//Util类被执行过
	expect(Util.mock.instances[0].funA).toHaveBeenCalled()		//判断Util类里面实例的方法funA是否执行过
})
```
4. 单元测试:对一个单元文件进行测试
5. 集成测试:对一个单元及单元内包括的内容进行测试
